from tkinter import *
from tkinter import ttk
from PIL import Image, ImageTk
import random
import math
import tkinter.messagebox as mb

# Создание окна регистрации и аторизации
root = Tk()
root.title("Регистрация и авторизация")
root.geometry("400x400")
frame = Frame(root)
au_password = StringVar()
reg_password = StringVar()
au_login = StringVar()
reg_login = StringVar()
bg = PhotoImage(file="backgrimage.png")

hod = 1
ngo = 1
y_last = 0
x_last= 0
count_wcheck = 0
count_bcheck = 0
sum_pole = 0

# Массив моделирования игрового поля
global chessplace
chessplace = [[0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0]]
global pole
pole = [[0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0]]

# Ввод логина и пароля в окне регистрации и авторизации
def entry_regist_and_login():
    # Регистрация
    canvas = Canvas(root, width=400, height=400)
    canvas.pack(fill="both", expand=True)
    canvas.create_image(0, 0, image=bg, anchor="nw")
    canvas.create_text(200, 25, text='Регистрация', font='30', fill="#FFFFFF")
    canvas.create_text(200, 60, text='Введите логин')
    entry_login = Entry(root, textvariable=reg_login)
    entry_login = canvas.create_window(140, 70, anchor="nw", window=entry_login)
    canvas.create_text(200, 110, text='Введите пароль')
    entry_password = Entry(root, textvariable=reg_password, show='*')
    entry_password = canvas.create_window(140, 120, anchor="nw", window=entry_password)
    button_a = Button(root, text='Зарегистрироваться', command=reg_login_and_password_error, bg='#FFFFFF')
    button_a = canvas.create_window(140, 160, anchor="nw", window=button_a)
    # Авторизация
    canvas.create_text(200, 220, text='Авторизация', font='30', fill="#FFFFFF")
    canvas.create_text(200, 250, text='Введите логин')
    entry_login = Entry(root, textvariable=au_login)
    entry_login = canvas.create_window(140, 260, anchor="nw", window=entry_login)
    canvas.create_text(200, 300, text='Введите пароль')
    entry_password = Entry(root, textvariable=au_password, show='*')
    entry_password = canvas.create_window(140, 310, anchor="nw", window=entry_password)
    button_r = Button(root, text='Авторизироваться', command=au_login_and_password_error, bg='#FFFFFF')
    button_r = canvas.create_window(145, 350, anchor="nw", window=button_r)

# Проверка на ошибку авторизации
def au_login_and_password_error():
    if (len(au_login.get()) == 0 or len(au_password.get()) == 0) or (
            len(au_login.get()) == 0 and len(au_password.get()) == 0) or au_login.get().count(' ') > 0 or \
            au_password.get().count(' ') > 0:
        mb.showerror("Ошибка", "Должны быть введены данные")
    else:
        file = open('reg_login.txt', 'r')
        while TRUE:
            line = file.readline()
            line = line.split()
            # Ошибка авторизации
            if len(line) == 0:
                file.close()
                mb.showerror("Ошибка", "Неверные логин или пароль")
                break
            # Успешная авторизация
            elif line[0] == au_login.get() and line[1] == au_password.get():
                file.close()
                root.destroy()
                window = Tk()
                window.title("Успешная авторизация")
                window.geometry("400x400")
                canvas = Canvas(window, width=400, height=400)
                canvas.pack(fill="both", expand=True)
                img = PhotoImage(file="bckgrimg.png")
                image = canvas.create_image(200, 200, image = img)
                canvas.create_text(200, 200, text='Вы успешно авторизированы!', font='30')
                button_w = Button(window, text='Начать игру', command= lambda: draw_chessboard(window, white_win, black_win))
                button_w = canvas.create_window(200, 250, window=button_w)
                window.grab_set()
                window.resizable(width=False, height=False)
                window.mainloop()
                break

# Проверка на ошибку регистрации
def reg_login_and_password_error():
    # Проверка на пустое поле
    if (len(reg_login.get()) == 0 or len(reg_password.get()) == 0) or (
        len(reg_login.get()) == 0 and len(reg_password.get()) == 0) or reg_login.get().count(' ') > 0 or \
        reg_password.get().count(' ') > 0:
        mb.showerror("Ошибка", "Введены неверные данные")
    # Проверка на длину логина и пароля
    elif len(reg_login.get()) <= 5 or len(reg_password.get()) <= 5:
        mb.showerror("Ошибка", "Логин и пароль должны состоять не менее чем из 6 символов")
    else:
        file = open('reg_login.txt', 'r')
        while TRUE:
            line = file.readline()
            line = line.split()
            # Проверка на совпадение логина и пароля
            if len(line) > 0 and line[0] == reg_login.get() and line[1] == reg_password.get():
                file.close()
                mb.showerror("Ошибка", "Логин и пароль уже существуют")
                break
            # Успешня регистрация
            else:
                file.close()
                file = open('reg_login.txt', 'a+')
                file.write(reg_login.get() + ' ' + reg_password.get() + '\n')
                file.close()
                mb.showinfo("Успешная регистрация", "Вы успешно зарегистрировались. Пожалуйста, авторизуйтесь")
                break
entry_regist_and_login()

# Отрисовка игрового поля
def draw_chessboard(window, white_win, black_win):
    global poz_cher_x,poz_cher_y,poz_bel_x,poz_bel_y
    window.destroy()
    global chessboard
    chessboard = Tk()
    chessboard.title("Текущая игра")
    chessboard.geometry("900x900")
    chessboard.resizable(width=False, height=False)
    canvas = Canvas(chessboard)
    canvas.pack(fill="both", expand=True)
    # Буквенные обозначения по краям поля
    # Снизу
    canvas.create_text(100, 875, text='A'), canvas.create_text(200, 875, text='B'), canvas.create_text(300, 875, text='C')
    canvas.create_text(400, 875, text='D'), canvas.create_text(500, 875, text='E'), canvas.create_text(600, 875, text='F')
    canvas.create_text(700, 875, text='G'), canvas.create_text(800, 875, text='H')
    # Сверху
    canvas.create_text(100, 25, text='H'), canvas.create_text(200, 25, text='G'), canvas.create_text(300, 25, text='F')
    canvas.create_text(400, 25, text='E'), canvas.create_text(500, 25, text='D'), canvas.create_text(600, 25, text='C')
    canvas.create_text(700, 25, text='B'), canvas.create_text(800, 25, text='A')
    # Численные обозначения по краям поля
    # Справа
    canvas.create_text(875, 100, text='1'), canvas.create_text(875, 200, text='2'), canvas.create_text(875, 300, text='3')
    canvas.create_text(875, 400, text='4'), canvas.create_text(875, 500, text='5'), canvas.create_text(875, 600, text='6')
    canvas.create_text(875, 700, text='7'), canvas.create_text(875, 800, text='8')
    # Слева
    canvas.create_text(25, 100, text='8'), canvas.create_text(25, 200, text='7'), canvas.create_text(25, 300, text='6')
    canvas.create_text(25, 400, text='5'), canvas.create_text(25, 500, text='4'), canvas.create_text(25, 600, text='3')
    canvas.create_text(25, 700, text='2'), canvas.create_text(25, 800, text='1')
    # Создание шахматных клеток
    canvas_board = Canvas(chessboard, bg='white', width=800, height=800)
    canvas_board.place(x=50, y=50)
    global color
    worb = 0
    row = 0
    col = 0
    # Определение цвета клетки
    for i in range(8):
        for j in range(8):
            worb += 1
            if i % 2 == 0:
                if worb % 2 == 0:
                    color = "white"
                else:
                    color = "black"
            elif i % 2 != 0:
                if worb % 2 != 0:
                    color = "white"
                else:
                    color = "black"
            pole[i][j] = (Button(chessboard, bg=color, relief="flat",command=lambda worb =worb,i=i, j=j: check_figure(worb,i,j)))
            canvas_board.create_window(row, col, anchor=NW, window=pole[i][j], width=100, height=100)
            row += 100
        row = 0
        col += 100
    # Размещение шахматных фигур на поле
    global img1 ,img2,img3,circle,img4,check_shah_bel,check_shah_cher,poz_lad_x_bel,poz_lad_y_bel,poz_lad_x_cher,poz_lad_y_cher
    circle = PhotoImage(master= canvas_board,file="greencircle.png")  # Подсказка хода
    img1 = PhotoImage(master= canvas_board,file="img10.png") # Белая ладья
    img2 = PhotoImage(master= canvas_board,file="img20.png") # Черная ладья
    img3 = PhotoImage(master= canvas_board,file="img30.png") # Белый король
    img4 = PhotoImage(master= canvas_board,file="img40.png") # Черный король
    # Начальное расположение
    x_wking = random.randint(1, 6)
    y_wking = random.randint(1, 6)
    x_bking = random.randint(1, 6)
    y_bking = random.randint(1, 6)
    x_wrook = random.randint(0, 7)
    y_wrook = random.randint(0, 7)
    x_brook = random.randint(0, 7)
    y_brook = random.randint(0, 7)
    # Выставление веса фигур и картинок
    # Белая ладья
    if chessplace[x_wrook][y_wrook] == 0:
        chessplace[x_wrook][y_wrook] = 1
        pole[x_wrook][y_wrook]['image'] = img1
    else:
        chessplace[x_wrook + 1][y_wrook] = 1
        pole[x_wrook + 1][y_wrook]['image'] = img1
    # Черная ладья
    if chessplace[x_brook][y_brook] == 0:
        chessplace[x_brook][y_brook] = -1
        pole[x_brook][y_brook]['image'] = img2
    else:
        chessplace[x_brook+1][y_brook] = -1
        pole[x_brook+1][y_brook]['image'] = img2
    # Белый король
    if chessplace[x_wking][y_wking] == 0:
        chessplace[x_wking][y_wking] = 2
        pole[x_wking][y_wking]['image'] = img4
    else:
        chessplace[x_wking+1][y_wking] = 2
        pole[x_wking+1][y_wking]['image'] = img4
    # Черный король
    if chessplace[x_bking][y_bking] == 0:
        chessplace[x_bking][y_bking] = -2
        pole[x_bking][y_bking]['image'] = img3
    else:
        chessplace[x_bking + 1][y_bking] = -2
        pole[x_bking+1][y_bking]['image'] = img3
    chessboard.mainloop()

# Проверка на правильность хода
def check_hod(x,y,k,clear):
    # Установка подсказок
    if clear == 0:
        if k == 1 or k == -1: # Ладья
            for i in range(y+1, 8): # Ход вверх
                if (i>=0 and i<8) and pole[x][i]['image'] == '':
                    pole[x][i]['image'] = circle
                elif (i>=0 and i<8) and pole[x][i]['image'] != '':
                        break
            for i1 in range(y-1, 0-1, -1): # Ход вниз
                if (i1>=0 and i1<8) and pole[x][i1]['image'] == '':
                    pole[x][i1]['image'] = circle
                elif (i1>=0 and i1<8) and pole[x][i1]['image'] != '':
                        break
            for i2 in range(x+1, 8): # Ход вправо
                if (i2>=0 and i2<8) and pole[i2][y]['image'] == '':
                    pole[i2][y]['image'] = circle
                elif (i2>=0 and i2<8) and pole[i2][y]['image'] != '':
                    break
            for i3 in range(x-1, 0-1, -1): # Ход влево
                if (i3>=0 and i3<8) and pole[i3][y]['image'] == '':
                    pole[i3][y]['image'] = circle
                elif (i3>=0 and i3<8) and pole[i3][y]['image'] != '':
                    break
        elif k == 2 or k == -2: # Король
            for i in range(x-1, x+2):
                for j in range(y-1, y+2):
                    if ((i>=0 and i<8) and (j>=0 and j<8)) and pole[i][j]['image'] == '':
                        pole[i][j]['image'] = circle
    # Удаление подсказок
    elif clear == 1:
        if k == 1 or k == -1: # Ладья
            for i in range(y+1, 8): # Ход вверх
                if (i>=0 and i<8) and chessplace[x][i] == 0:
                    pole[x][i]['image'] = ''
            for i1 in range(y-1, 0-1, -1): # Ход вниз
                if (i1>=0 and i1<8)and chessplace[x][i1] == 0:
                    pole[x][i1]['image'] = ''
            for i2 in range(x+1, 8): # Ход вправо
                if (i2>=0 and i2<8)and chessplace[i2][y] == 0:
                    pole[i2][y]['image'] = ''
            for i3 in range(x-1, 0 - 1, -1): # Ход влево
                if (i3>=0 and i3<8) and chessplace[i3][y] == 0:
                    pole[i3][y]['image'] = ''
        elif k == 2 or k == -2: # Король
            for i in range(x-2, x+2):
                for j in range(y-2, y+2):
                    if ((i>=0 and i<8) and (j>=0 and j<8)) and chessplace[i][j] == 0:
                        pole[i][j]['image'] = ''

# Проверка на правильность выбора фигуры и ход
def check_figure(i,x,y):
    global hod, ngo,x_last,y_last,last_color,last_image
    # Первое нажатие
    if ngo == 1 and pole[x][y]['image']!='':
        if hod == 1: # Ход белых
            if chessplace[x][y] == 1 or chessplace[x][y] == 2:
                ngo = 2
                hod += 1
                last_image = pole[x][y]['image']
                x_last = x
                y_last = y
                check_hod(x, y, chessplace[x][y], 0)
            else:
                mb.showerror(title="error", message="Сейчас ходят белые")
        elif hod == 2: # Ход черных
            if chessplace[x][y] == -1 or chessplace[x][y] == -2:
                ngo = 2
                last_image = pole[x][y]['image']
                x_last = x
                y_last = y
                check_hod(x, y, chessplace[x][y], 0)
                hod -= 1
            else:
                mb.showerror(title="error", message="Сейчас ходят черные")
    # Второе нажатие
    elif ngo == 2 and pole[x][y]['image']!='':
        global sum_pole
        if pole[x][y]['image'] == str(circle):
            chessplace[x][y] = chessplace[x_last][y_last]
            chessplace[x_last][y_last] = 0
            pole[x][y]['image'] = last_image
            pole[x_last][y_last]['image'] = ''
            check_hod(x_last, y_last, chessplace[x][y], 1)
            ngo = 1
            check_hod(x,y,chessplace[x][y], 2)
            check_and_mate()
        elif hod == 2 and chessplace[x][y] == -1: # Съесть черную ладью
            chessplace[x][y] = chessplace[x_last][y_last]
            chessplace[x_last][y_last] = 0
            pole[x][y]['image'] = last_image
            pole[x_last][y_last]['image'] = ''
            check_hod(x_last, y_last, chessplace[x][y], 1)
            sum_pole += 1
            ngo = 1
            check_hod(x,y,chessplace[x][y], 2)
            result(white_win, black_win)
        elif hod == 1 and chessplace[x][y] == 1: # Съесть белую ладью
            chessplace[x][y] = chessplace[x_last][y_last]
            chessplace[x_last][y_last] = 0
            pole[x][y]['image'] = last_image
            pole[x_last][y_last]['image'] = ''
            check_hod(x_last, y_last, chessplace[x][y], 1)
            sum_pole -= 1
            ngo = 1
            check_hod(x, y, chessplace[x][y], 2)
            result(white_win, black_win)
    else:
        mb.showerror(title="error", message="Неправильный ход")

# Определение результата игры
def result(white_win, black_win):
    global end
    if count_wcheck == 8: # 8 шахов, победа черных
        black_win(chessboard, end_of_play, result)
    elif count_bcheck == 8: # 8 шахов, победа белых
        white_win(chessboard, end_of_play, result)
    global sum_pole
    if sum_pole == -1: # Съедена белая ладья, победа черных
        black_win(chessboard, end_of_play, result)
    elif sum_pole == 1: # Съедена черная ладья, победа белых
        white_win(chessboard, end_of_play, result)

# Вывод результата игры, победа белых
def white_win(chessboard, end_of_play, result):
    chessboard.destroy()
    end = Tk()
    end.title("Игра завершена")
    end.geometry("400x400")
    canvas = Canvas(end, width=400, height=400)
    canvas.pack(fill="both", expand=True)
    img = PhotoImage(file="end.png")
    image = canvas.create_image(200, 200, image=img)
    canvas.create_text(200, 200, text='Победили белые!')
    button_e = Button(end, text='Завершить игру', command=lambda: end_of_play(end))
    button_e = canvas.create_window(200, 250, window=button_e)
    end.grab_set()
    end.resizable(width=False, height=False)
    end.mainloop()

# Вывод результата игры, победа черных
def black_win(chessboard, end_of_play, result):
    chessboard.destroy()
    end = Tk()
    end.title("Игра завершена")
    end.geometry("400x400")
    canvas = Canvas(end, width=400, height=400)
    canvas.pack(fill="both", expand=True)
    img = PhotoImage(file="end.png")
    image = canvas.create_image(200, 200, image=img)
    canvas.create_text(200, 200, text='Победили черные!')
    button_e = Button(end, text='Завершить игру', command=lambda: end_of_play(end))
    button_e = canvas.create_window(200, 250, window=button_e)
    end.grab_set()
    end.resizable(width=False, height=False)
    end.mainloop()

# Завершение игры
def end_of_play(end):
    end.destroy()

# Проверка на шах
def check_and_mate():
    global count_wcheck, count_bcheck
    for x in range(1,8):
        for j in range(1,8):
            if chessplace[x][j] == 2:  # Для белого короля
                # По вертикали
                for i in range(j+1,8):
                    if (i>=0 and i<8) and chessplace[x][i] == -1:
                        mb.showinfo(title="whitecheck", message="Шах белым")
                        count_wcheck += 1
                        result(chessboard, end_of_play)
                for i1 in range(j-1, 0-1, -1):
                    if (i1 >= 0 and i1 < 8) and chessplace[x][i1] == -1:
                        mb.showinfo(title="whitecheck", message="Шах белым")
                        count_wcheck += 1
                        result(chessboard, end_of_play)
                # По горизонтали
                for i2 in range(x+1, 8):
                    if (i2>=0 and i2<8) and chessplace[i2][j] == -1:
                        mb.showinfo(title="whitecheck", message="Шах белым")
                        count_wcheck += 1
                        result(chessboard, end_of_play)
                for i3 in range(x-1, 0-1, -1):
                    if (i3>=0 and i3<8) and chessplace[i3][j] == -1:
                        mb.showinfo(title="whitecheck", message="Шах белым")
                        count_wcheck += 1
                        result(chessboard, end_of_play)
            elif chessplace[x][j] == -2:  # Для черного короля
                # По вертикали
                for i in range(j+1,8):
                    if (i>=0 and i<8) and chessplace[x][i] == 1:
                        mb.showinfo(title="whitecheck", message="Шах черным")
                        count_bcheck += 1
                        result(chessboard, end_of_play)
                for i1 in range(j-1, 0-1, -1):
                    if (i1 >= 0 and i1 < 8) and chessplace[x][i1] == 1:
                        mb.showinfo(title="whitecheck", message="Шах черным")
                        count_bcheck += 1
                        result(chessboard, end_of_play)
                # По горизонтали
                for i2 in range(x+1,8):
                    if (i2>=0 and i2<8) and chessplace[i2][j] == 1:
                        mb.showinfo(title="whitecheck", message="Шах черным")
                        count_bcheck += 1
                        result(chessboard, end_of_play)
                for i3 in range(x-1, 0-1, -1):
                    if (i3>=0 and i3<8) and chessplace[i3][j] == 1:
                        mb.showinfo(title="whitecheck", message="Шах черным")
                        count_bcheck += 1
                        result(chessboard, end_of_play)

root.resizable(width=False, height=False)
root.mainloop()
